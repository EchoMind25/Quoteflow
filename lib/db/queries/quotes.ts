import { createClient } from "@/lib/supabase/server";
import type {
  Quote,
  QuoteInsert,
  QuoteUpdate,
  QuoteLineItemInsert,
  QuoteStatus,
  QuoteWithDetails,
} from "@/types/database";

export type GetQuotesOptions = {
  status?: QuoteStatus;
  customerId?: string;
  limit?: number;
  offset?: number;
};

export async function getQuotes(options: GetQuotesOptions = {}) {
  const { status, customerId, limit = 25, offset = 0 } = options;
  const supabase = await createClient();

  let query = supabase
    .from("quotes")
    .select(
      `
      *,
      customer:customers(id, first_name, last_name, email, phone),
      creator:profiles!quotes_created_by_fkey(first_name, last_name)
    `,
      { count: "exact" },
    )
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (status) {
    query = query.eq("status", status);
  }
  if (customerId) {
    query = query.eq("customer_id", customerId);
  }

  const { data, error, count } = await query;
  if (error) throw error;

  return { quotes: data, count };
}

export async function getQuoteById(
  id: string,
): Promise<QuoteWithDetails | null> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from("quotes")
    .select(
      `
      *,
      line_items:quote_line_items(*),
      customer:customers(*),
      business:businesses(name, logo_url, primary_color)
    `,
    )
    .eq("id", id)
    .single();

  if (error) {
    if (error.code === "PGRST116") return null;
    throw error;
  }

  return data as unknown as QuoteWithDetails;
}

export async function createQuote(
  input: Omit<QuoteInsert, "quote_number"> & {
    line_items?: Omit<QuoteLineItemInsert, "quote_id">[];
  },
) {
  const supabase = await createClient();
  const { line_items: lineItems, ...quoteData } = input;

  // Insert the quote (quote_number is generated by the DB trigger)
  const { data: quote, error: quoteError } = await supabase
    .from("quotes")
    .insert(quoteData)
    .select()
    .single();

  if (quoteError) throw quoteError;

  // Insert line items if provided
  if (lineItems && lineItems.length > 0) {
    const rows = lineItems.map((item, index) => ({
      ...item,
      quote_id: quote.id,
      sort_order: item.sort_order ?? index,
    }));

    const { error: lineItemsError } = await supabase
      .from("quote_line_items")
      .insert(rows);

    if (lineItemsError) throw lineItemsError;
  }

  // Re-fetch to get computed totals from the DB trigger
  return getQuoteById(quote.id);
}

export async function updateQuote(id: string, updates: QuoteUpdate) {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from("quotes")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) throw error;
  return data as Quote;
}

export async function updateQuoteStatus(id: string, status: QuoteStatus) {
  const timestampField: Partial<Record<QuoteStatus, string>> = {
    sent: "sent_at",
    viewed: "viewed_at",
    accepted: "accepted_at",
    declined: "declined_at",
  };

  const updates: QuoteUpdate = { status };
  const tsField = timestampField[status];
  if (tsField) {
    (updates as Record<string, unknown>)[tsField] = new Date().toISOString();
  }

  return updateQuote(id, updates);
}
